---
title: "SSL/TLS メモ（ハンドシェイク・証明書・KTLS）"
---

# SSL/TLS メモ（ハンドシェイク・証明書・KTLS）

SSL/TLS は「暗号化」そのものより、
**どこで何が決まって、どこで何が検証されて、どこからが“データ暗号化フェーズ”なのか**を掴むと一気に楽になります。

---

## まず結論

- TCP は「届く道」を作る（信頼できるストリームを作る）
- TLS は「その道を盗み見・改ざんされない道」にする（暗号・鍵・相手確認を決める）
- 証明書は「共通鍵を作る材料」ではなく、基本は **相手（サーバ）を信用してよい根拠**
- KTLS は「**ハンドシェイク後のレコード暗号化**」の一部をカーネルへ逃がす仕組み（万能じゃない）

---

## キーワード辞書

- **認証（Authentication）**：相手が“名乗ってる通り”か
- **機密性（Confidentiality）**：盗み見できない
- **完全性（Integrity）**：改ざん検知できる
- **PFS（Forward Secrecy）**：サーバ秘密鍵が漏れても“過去の通信”は復号されにくい
- **鍵交換（Key Exchange）**：共通鍵（セッション鍵）を合意するやり方（例：ECDHE）
- **証明書チェーン**：サーバ証明書 → 中間CA → ルートCA（の信頼）
- **SNI**：1つのIPで複数ドメインをHTTPSするために、ClientHelloで「このホスト名ね」を送る
- **ALPN**：HTTP/2 や HTTP/1.1 など“上のプロトコル”をTLS内で合意する

---

## TCP と TLS のハンドシェイクの違い

まず“図”で置いとくとこう（TLS は TCP の上でやる）：

```text
TCP 3-way handshake（通信路の確立）

Client                                      Server
  |                                            |
  |  SYN  -----------------------------------> |
  |  SYN/ACK <--------------------------------- |
  |  ACK  -----------------------------------> |
  |
  |  （ここから「TCPでデータを流せる」状態）


TLS handshake（暗号通信の準備：合意と検証）

Client                                      Server
  |                                            |
  |  ClientHello ----------------------------> |
  |               ServerHello ---------------- |
  |               Certificate ---------------- |
  |               （必要なら）CertificateRequest
  |               （TLS1.2だと）ServerKeyExchange
  |  （TLS1.2だと）ClientKeyExchange --------> |
  |  Finished <------------------------------> |
  |
  |  （ここから「アプリデータが暗号化されて流れる」）
  |  Application Data <======================> |
```

TLS1.3 主流版：

```text
TLS 1.3 handshake（だいぶ 1-RTT 寄り）

Client                                      Server
  |                                            |
  |  ClientHello ----------------------------> |
  |   - supported_versions: TLS1.3             |
  |   - key_share: (ECDHEの材料を先に出す)     |
  |   - SNI/ALPN など                           |
  |               ServerHello ---------------- |
  |                - key_share（合意）          |
  |               EncryptedExtensions -------- |
  |               Certificate ---------------- |
  |               CertificateVerify ---------- |
  |               Finished <----------------- |
  |  Finished -------------------------------->|
  |
  |  Application Data <======================> |

メモ：
  - TLS1.2にあった ChangeCipherSpec の“儀式”は基本消える（互換で出る例外はある）
  - 0-RTT（早期データ）は条件付きで別枠（リプレイ耐性など注意点あり）
```

### TCP：通信路の確立

- 目的：パケットを“順序付きで”届けるストリームを作る
- 典型：`SYN → SYN/ACK → ACK`

もう少し噛み砕くと、TCP がやってくれるのはだいたいこれ：

- **コネクション指向**：
	- 「この 4 要素（srcIP:srcPort → dstIP:dstPort）の会話」を 1 本の接続として扱う
- **順序保証**：
	- IP は順番どおりに届くとは限らないけど、TCP は受信側で並べ直して“順序付きストリーム”にする
- **再送制御**：
	- 途中で落ちた/欠けたら ACK を見て再送する（だからアプリは“だいたい届く前提”で書ける）
- **フロー制御（受信側都合）**：
	- 受信バッファが溢れないように、ウィンドウサイズで「今これくらいまで送っていいよ」を調整する
- **輻輳制御（ネットワーク都合）**：
	- 混んでるっぽい時は送信を絞る（ここがあるから、単純に回線いっぱいまで送るだけじゃない）

3-way handshake の「意味」は、単に挨拶じゃなくて：

- 双方向に到達できることを確認しつつ
- **初期シーケンス番号（ISN）** を決めて
- TCP オプション（MSS / Window Scale / SACK など）をすり合わせて
- 以降の再送・順序制御の土台を作る

注意：TCP が成立しても、アプリ的に“正しい相手”とは限らないです。
（例：443 につながったけど、それが本当に example.com か？は TCP では保証しない → そこをやるのが TLS の証明書検証）

TCP の時点では「暗号化」「証明書」はまだ関係なし。

### TLS：暗号通信の準備（合意と検証）

- 目的：
	- 暗号スイート（どの暗号でやるか）
	- 相手の認証（証明書検証）
	- セッション鍵（共通鍵）
	- 以降の通信を暗号化する合意

要点を整理すると、
**TCPで通信路（信頼できるストリーム）を作る → TLSで暗号方式・鍵・相手認証を合意する → 以降のアプリデータが暗号化されて流れる**。

---

## TLSハンドシェイク：TLS1.2 と TLS1.3 の見取り図

同じTLSでも 1.2 と 1.3 で“分かれ道”があるので、そこを押さえるのが良いです。

### TLS 1.2（概念図）

- `ClientHello`：
	- 対応できる暗号スイート候補
	- SNI/ALPN など拡張
- `ServerHello`：
	- 使う暗号スイートを確定
- `Certificate`：
	- サーバ証明書（チェーン）提示
- `ServerKeyExchange`（ECDHE のとき重要）：
	- サーバが“鍵交換パラメータ”を提示し、証明書の秘密鍵で署名
- `ClientKeyExchange`：
	- 鍵交換のための情報を返す
- `ChangeCipherSpec` / `Finished`：
	- 「ここから暗号化するよ」合意

※ ここで“証明書”が効くのは主に **相手の正当性** と、ECDHEの署名検証（改ざん防止）です。

### TLS 1.3

- **ClientHello の中に KeyShare（鍵交換の材料）を載せる**
	- TLS1.2 だと「Hello 往復してから鍵交換の中身」が来がちだったけど、
	  TLS1.3 は **最初の ClientHello で ECDHE の材料を先出し**してしまう。
	- これでサーバは初回応答（ServerHello）で鍵合意まで進められて、
	  **ハンドシェイクの往復回数（体感レイテンシ）が減りやすい**。

- **1-RTT（ふつうは 1 往復で暗号化通信に入れる）**
	- 図で言うと、ServerHello 以降は（拡張や証明書を含め）どんどん暗号化側へ寄っていく。
	- HTTP/2/3 の「接続してすぐ喋りたい」需要と相性が良くて、結果として“速い”に繋がりやすい。

- **RSA 鍵交換が消える（重要）**
	- TLS1.3 の鍵交換は基本 ECDHE 系。
	- 証明書は「鍵を包む」よりも、
	  **サーバが出してきた鍵交換パラメータが本物で改ざんされてないことの保証（署名）**が主役になりやすい。
	- ここが「証明書＝共通鍵生成」って誤解を生みにくくしてくれてる感じ。

- **暗号スイートの意味が整理される**
	- TLS1.2 までの「鍵交換方式 + 認証 + 暗号 + MAC」みたいなゴチャ混ぜから、
	  TLS1.3 は **主に AEAD（例：AES-GCM / ChaCha20-Poly1305）+ ハッシュ**の選択になる。
	- 細かいけど、運用で設定を読むときに事故りにくい。

- **セッション再開（Resumption）と 0-RTT（早期データ）**
	- 再接続で速くできる仕組みが用意されていて、条件が揃うと 0-RTT もあり得る。
	- ただし 0-RTT は「リプレイされ得る」ので、
	  書き込み系（副作用のあるリクエスト）に乗せるのは慎重に、ってやつ。

#### じゃあ、KTLS は TLS1.3 だと何が難しいのか？

KTLS はざっくり「ハンドシェイク後のレコード暗号化をカーネルに寄せる」ってことなんだけど、
TLS1.3 だと次の理由で **“条件が揃わないと乗りにくい / 観測しにくい”** 側に寄ります。

- **実装と対応範囲の問題**
	- KTLS の実運用は TLS1.2（特に AES-GCM）で話が通りやすい時期が長かった。
	- TLS1.3 は実装・連携（OpenSSL ⇄ カーネル ⇄ Webサーバ）の成熟度や対応範囲に左右されやすい。

- **TLS1.3 は“接続中に鍵が切り替わる/増える”要素が増える**
	- ハンドシェイク用鍵とアプリデータ用鍵の分離がより明確で、
	  さらに KeyUpdate（鍵更新）みたいな動的要素もある。
	- こういう要素は、ユーザー空間ライブラリとカーネル側の状態同期がシビアになりがち。

- **0-RTT や各種拡張が絡むと、なおさら“標準のデータパス”から外れやすい**
	- KTLS を使えるかどうかは、暗号だけじゃなくて送受信のやり方（バッファリング等）にも依存する。
	- なので「TLS1.3 を使ってる」だけで自動的に KTLS が効く、とは基本ならない。

結論としては、
**TLS1.3 は主流だけど、KTLS は“勝手に効くもの”じゃなくて観測前提で扱う**のが安全です。

---

## Let's Encrypt 証明書が“使われるタイミング”

### 1) 証明書は「いつ提示される？」

- TLS ハンドシェイク中の `Certificate` で、サーバがクライアントへ送ります
	- “Let's Encrypt の証明書”というより、**そのドメイン用に発行されたサーバ証明書 + 中間CA** が送られるイメージ

### 2) クライアントは「何を検証する？」

- 期限：NotBefore / NotAfter
- 名前：CN ではなく **SAN（Subject Alternative Name）** が実質本体
- 署名：
	- サーバ証明書が中間CAで署名されているか
	- 中間CAがルートに繋がるか（信頼ストアにあるか）

「合格」すると、少なくとも *この接続先がそのドメインを名乗る正当性* を満たします。

#### 補足：Let's Encrypt について

- Let's Encrypt は「無料で使える認証局（CA）」で、主に **HTTPS を普及させる（暗号化を当たり前にする）**のが目的
- 発行される証明書は基本 **DV（Domain Validation）** の範囲なので、検証できるのは基本「そのドメインをコントロールしてる」まで
- つまり、悪い人でも条件を満たせば取れてしまうので、
	- 「通信が暗号化されてる」
	- 「（少なくとも）そのドメイン名の相手と喋ってる」

	は言えるけど、

	- 「このサイトが善良」
	- 「サービス内容が正しい」
	- 「運営者が信頼できる」

	みたいな“サイトの信憑性”までは保証しない。
	（有償の OV/EV 証明書は「組織の実在性チェック」が追加されるけど、それでも“安全なサイト”を保証する魔法ではないし、最近はブラウザ表示の差も小さめ）

### 3) 鍵交換で証明書はどう絡む？（RSA と ECDHE を切り分け）

- RSA 鍵交換（古め・今は推奨されにくい）
	- 証明書の公開鍵で、クライアントが作った秘密（Pre-Master Secret）を暗号化して送る
	- サーバ秘密鍵が漏れると、過去通信が復号されやすくなる方向（PFS弱い）
- ECDHE（今どきの主役）
	- “共通鍵”は ECDHE の計算で作る
	- 証明書は「ECDHEのパラメータがサーバ由来で改ざんされてない」ことを署名で保証する

まとめると：
**証明書は「相手（サーバ）がそのドメインを名乗ってよい根拠（身分証）」**。
**共通鍵（セッション鍵）の合意は、いまどきは主に ECDHE が担当**。

---

## ACME / certbot は TLS のどこにいる？

ここは混乱しがちなので、整理して記載します。

- **ACME**：
	- 認証局（例：Let's Encrypt）とクライアント（certbot等）が「証明書を発行/更新する」ためのプロトコル
- **certbot**：
	- ACME クライアント実装のひとつ（証明書を取りに行って、ファイルに落として、必要ならWebサーバを調整する）
- **TLS（Webアクセス時）**：
	- ユーザのブラウザ/クライアントと、あなたのWebサーバが「発行済みの証明書」を使って暗号化通信する仕組み

### 全体フロー（どこで何が起きる？）

```text
（証明書を取るとき：発行/更新）
certbot  <---(ACME: HTTPS API)--->  Let's Encrypt
   |
   | 1) ドメイン所有の確認（Challenge）を通す
   | 2) 証明書チェーンをダウンロード
   v
/etc/letsencrypt/live/<domain>/
  - privkey.pem   （秘密鍵）
  - fullchain.pem （サーバ証明書 + 中間CA）
   |
   | 3) Webサーバへ反映（設定 or reload）
   v
nginx/apache が新しい証明書を読み込む


（ユーザがアクセスするとき：通常のTLS）
Browser/Client  <---(TLS handshake)-->  nginx/apache  <---(HTTPアプリ)--->  Backend
```

ポイントはこれ：

- certbot は **「証明書を入手して、配置して、反映させる」側**
- TLS ハンドシェイクは **「ユーザが https:// でアクセスした瞬間に、Webサーバがやる」側**

なので、通常アクセスの TLS ハンドシェイク中に certbot が登場することは基本ないです。

### ドメイン所有確認（Challenge）

ACME は「そのドメインを本当にコントロールしてる？」を確認してから証明書を発行します。
代表的な確認方法はこの3つ。

- **HTTP-01**：
	- `http://<domain>/.well-known/acme-challenge/<token>` が取れることを確認
	- だいたい **TCP/80** が必要（リダイレクトやWAFで詰まることがある）
- **DNS-01**：
	- DNS の TXT レコードを置けることを確認
	- ワイルドカード（`*.example.com`）が欲しい時はこれが定番
- **TLS-ALPN-01**：
	- **TCP/443** で ALPN を使った検証（`acme-tls/1`）
	- “検証用の一時証明書”を出す挙動になるので、構成によっては注意が要る

※ ここでの「検証のための接続（HTTP/TLS）」は、証明書を発行するための手続き。
ユーザ向けの通常TLSとは目的が違う、って区別が大事です。

### certbot がやること / やらないこと

やること：

- ACME で注文（order）→ challenge を通す → 証明書を取得
- 証明書と鍵をファイルに保存（`privkey.pem` は超重要：漏れたら終わる）
- プラグイン次第で、Webサーバ設定の追記/修正（例：`--nginx` / `--apache` / `--webroot`）
- 更新（renew）を回す（systemd timer や cron）
- 更新後に reload する（設定次第。ここが抜けると更新したのに反映されない）

やらないこと（通常アクセス時）：

- ユーザがアクセスした瞬間の TLS ハンドシェイクを“代わりに処理する”こと
- Webサーバの暗号化処理の高速化（それは OpenSSL / KTLS / アプリの責務）

### ありがちな「更新したのに期限切れ」パターン

- 証明書ファイルは更新されてるが、Webサーバが reload されておらず古い証明書を掴んだまま
- 80/443 の到達性が変わって HTTP-01 / TLS-ALPN-01 が通らなくなった
- DNS-01 の反映が遅くて検証に間に合わない

関連：運用手順は [setup-lets-encrypt.md](setup-lets-encrypt.md) に寄せるのが良いです。

---

## KTLS（Kernel TLS）って何がいいのか？どこまでやるのか？

KTLS を説明すると、
**「TLS の“暗号化されたデータ本体（レコード層）”の処理を、ユーザー空間ライブラリ（OpenSSL 等）からカーネルへ寄せられる仕組み」**です。

ここで大事なのは、KTLS は TLS を“全部”やるわけじゃなくて、
**ハンドシェイク後のデータパス最適化**に寄った機能、という立ち位置となります。

### 目的

- **CPU を浮かせたい**
	- ユーザー空間での暗号処理・コピー・システムコール往復を減らしたい
- **データコピーを減らしたい（特に大きい静的ファイル配信）**
	- `sendfile` のような “カーネル内でファイル→ソケットへ流す” 経路と相性が良い
	- うまくハマると、ユーザー空間にデータを持ち上げずに済む（= CPU とメモリ帯域の節約になりやすい）
- **NIC オフロードに繋げたい（環境次第）**
	- ここはハード/ドライバ/設定に強依存。
	- まずは「ソフトウェア的に KTLS が使えてるか」を観測してから、次の段階として考えるのが現実的。

### 役割分担（超重要）

TLS を「ハンドシェイク（合意と検証）」と「データ（暗号化された本体）」に分けると理解しやすいです。

- **ハンドシェイク（ユーザー空間）**
	- 証明書チェーン検証 / ホスト名（SAN）検証
	- 鍵交換（ECDHE）・鍵スケジュール
	- ALPN/SNI など拡張の処理
	- セッション再開（チケット等）
	- つまり “正しい相手か” と “どの鍵で暗号化するか” を決めるフェーズ

- **データ（レコード層：カーネルへ寄せられる可能性）**
	- アプリデータを TLS レコードに包む/ほどく
	- AEAD（AES-GCM/ChaCha20-Poly1305 等）の暗号化/復号
	- シーケンス番号や認証タグの整合性チェック

KTLS はここ。
**証明書検証はやりません**（= そこは OpenSSL 等の仕事）。

### 内部イメージ（“鍵を渡してデータパスを切り替える”）

ざっくりのIMGはこんな感じ。

```text
（ハンドシェイク）
nginx/apache
	-> OpenSSL が証明書検証・鍵交換・鍵スケジュールをやる

（ハンドシェイク完了後）
nginx/apache
	-> OpenSSL が「このコネクションのセッション鍵（対称鍵）」を
		 カーネルに渡せる条件なら渡す（= 以降のレコード処理をカーネルへ寄せる）

（アプリデータ送受信）
nginx/apache  --write()/sendfile()-->  kernel(tls)  ==> NIC
nginx/apache  <--read()--------------  kernel(tls)  <== NIC
```

ここで “渡す” というのは、
秘密鍵（証明書の秘密鍵）をカーネルに丸投げする話ではなく、
**確立済み接続のデータ暗号化に使うセッション鍵（対称鍵）を、そのソケットに紐付ける**イメージ。

### どこまで速くなる？（効く領域 / 効かない領域）

KTLS は万能最適化ではないので、期待値の置き方が大事。

- 効きやすい（嬉しさが出やすい）
	- 大きいレスポンス（静的ファイル、動画、ISO、アーティファクト配布）
	- `sendfile` や類似の経路を使える構成
	- TLS 終端（nginx/apache）が単純に“配ってる”構成

- 効きにくい（期待しすぎ注意）
	- ハンドシェイクの重さ（証明書検証や鍵交換）は基本そのまま
	- 小さく細かい write が大量（アプリがちょこちょこ送る、バッファリングが複雑）
	- 暗号スイート/プロトコル条件が合わない（後述）
	- アプリ側のボトルネック（DB待ち、テンプレ生成、圧縮、ログ、WAF 等）が支配的

### 制約

KTLS が乗るかは「カーネルが対応してる」だけでは決まりません。

- **プロトコル/暗号の条件**
	- 実装・ディストリ・バージョンにより、TLS1.2中心で相性が良かったり、TLS1.3 が限定的だったりする
	- AEAD でも全部OKとは限らない（環境ごとに観測が必要）
- **送受信パスの条件**
	- Webサーバが OpenSSL の KTLS を有効化できること
	- I/O の形（`sendfile` するのか、ユーザー空間で組み立てて書くのか）で効き方が変わる
- **状態同期の難しさ**
	- TLS1.3 では鍵の段階が整理されている分、KeyUpdate など動的要素もある
	- こういう要素が絡むと「ユーザー空間 ⇄ カーネル」の状態同期が難しくなり、KTLS が外れる/効かない理由になりやすい

---

## RHEL系OS と KTLS（現実的な見方）

ここは環境差があるので、断定より **観測で詰める**のが正解。
「OSが対応してるか」→「ライブラリが使えるか」→「Webサーバが踏むか」→「実際に使われたか」の順で見ます。

### まず結論（ありがちな落とし穴を先に）

- RHEL系 では、カーネル側に KTLS 機能が入っていることは多い
- でもデフォルトで勝手に使われるとは限らない（むしろ使われないことが普通にある）
- “Let's Encrypt だから”ではなく、
	- TLS バージョン
	- 暗号
	- Webサーバのビルド/設定
	- I/O の流れ

	で決まる

### ざっくり確認ポイント（Rocky9系での現実的手順）

- カーネル側（KTLS の窓口があるか）
	- `/proc/net/tls_stat` が存在するか
	- `modprobe tls` が通るか（必要な環境のみ）
- ユーザー空間（OpenSSL 側）
	- OpenSSL が KTLS を有効化できるAPI/設定を持っているか（ビルド/バージョン依存）
- Webサーバ側（踏みに行ってるか）
	- nginx/apache が「OpenSSL に KTLS を使わせる設定」を提供しているか
	- 例：Apache だと `SSLOpenSSLConfCmd Options KTLS` のような設定が使える環境がある（環境依存なので要確認）
	- nginx でも `ssl_conf_command` 系で OpenSSL のオプションを渡せる構成がある（同上）

※ ここは “設定名を暗記” じゃなくて、
**観測（tls_stat）→ その環境の Web サーバが KTLS を有効化できるか確認**の順が事故らない。

### ありがちな状態

- カーネル自体は KTLS を持っていることが多い
- ただし、アプリ（Nginx/Apache/独自サーバ）が
	- OpenSSL の KTLS 機能を実際に踏む
	- 条件に合う暗号・機能セットで動く
	- バッファリング/送受信方式が KTLS と相性が良い

…みたいな条件が揃わないと、**普通に“ユーザー空間でOpenSSLが全部やる”挙動になります**。

### 「Let's Encrypt を使うと KTLS が使われない？」問題

- Let's Encrypt かどうかは本質じゃない（証明書の発行元の話）
- KTLS を左右しがちなのは、だいたいこっち：
	- TLS 1.3 を優先している（KTLS の対応範囲・実装状況に左右される）
	- 使っている暗号スイートが対象外
	- Webサーバの送受信が KTLS へ寄せられない

もう一回だけ強調：
**Let's Encrypt は「どのCAの証明書か」の話で、KTLS は「暗号化データの処理をどこでやるか」の話。レイヤが違う**です。

---

## KTLS が“動いてるか”を観測する（これやると一気に強い）

### 1) TLS と暗号スイートを確認

まず、今のサーバが何で喋っているかを固定観測。

- 例：接続先の合意内容を見る
	- `openssl s_client -connect example.com:443 -servername example.com -alpn h2 -tls1_2`
	- `openssl s_client -connect example.com:443 -servername example.com -alpn h2 -tls1_3`

ここで「TLS1.2 なのか / 1.3 なのか」「暗号は何か」をまず押さえます。

### 2) KTLS の統計を見る

- `cat /proc/net/tls_stat`

ざっくり、通信を流した前後で値が増えるかを見るのが第一歩。
（※ カウンタの意味はカーネル実装に依るので、まずは増減を見るのが安全）

### 3) 負荷をかけて差を見る（ベンチというより“観測”）

- `curl -sS https://example.com/ >/dev/null` をループして `tls_stat` を見る

ここで増えない場合、
**KTLS が未使用**か、**対象条件に入ってない**か、**観測の仕方がズレてる**か、のどれか。

---

## KTLS を使うための概念チェックリスト（やることの順番）

「KTLSを使いたい」って言い出した瞬間に、最低限これを埋めると理解が前に進みます。

1. カーネルが KTLS を提供しているか
2. TLS ライブラリ（OpenSSL 等）が KTLS を使えるビルド/設定か
3. アプリ（Nginx/Apache/アプリ自身）が KTLS を踏む実装・設定になっているか
4. プロトコル/暗号が KTLS 対象条件に入っているか（ここで落ちがち）
5. `tls_stat` 等で“観測できる状態”になっているか

---

## よくある勘違いメモ

- 「証明書で共通鍵を作る」
	- だいたい違う（今どきは ECDHE で作り、証明書は署名検証/認証が主役）
- 「TLS の暗号化は最初から全部暗号」
	- 違う。まず合意（ハンドシェイク）があって、以降が暗号化データ
- 「KTLS は SSL/TLS をカーネルが全部やる」
	- 違う。ハンドシェイクは通常ユーザー空間。KTLS は主にデータパス最適化

---


